# golang垃圾回收机制

> 垃圾回收对于一门编程语言有着极其重要的作用，一方面它弱化了软件工程师编码过程中对资源回收的关注；另一方面也提高了编程的灵活性和易用性。软件工程师只需要关注具体待实现的功能细节，而不用关心资源如何回收、何时回收等问题。  
> 任何问题都需要用辩证的观点来分析。首先一门编程语言具有垃圾回收的机制，无疑对工程师是一件好事，但同时也需要意识到，复杂的垃圾回收算法和回收机制语言层面帮我们实现，并不意味着我们可以忽略它们，不去学习具体其底层原理和细节。**只有知其然，并知其所以然。才能更好的发挥其价值**。  
> 下文将以本人的理解+大白话来阐述垃圾回收，首先会从垃圾回收整个大的概念来介绍，这部分对任何编程语言具有通用性，只不过不同语言在解决同样的问题时，采用的具体实现不一样罢了。其次在第五部分重点以golang语言来分析其底层垃圾回收的机制。最后再对java中的垃圾回收和golang的垃圾回收做一个对比和总结，以便加强对垃圾回收机制的学习和理解。

* [golang垃圾回收机制](#golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6)
  * [1\.垃圾回收是什么？](#1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%98%AF%E4%BB%80%E4%B9%88)
    * [1\.1 什么是垃圾？](#11-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE)
    * [1\.2 什么是垃圾回收？](#12-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)
  * [2\.为什么需要垃圾回收？](#2%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)
  * [3\.什么时候触发垃圾回收？](#3%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)
    * [3\.1 垃圾回收触发条件](#31-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6)
    * [3\.2 线上垃圾回收出现的问题](#32-%E7%BA%BF%E4%B8%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98)
  * [4\.垃圾回收算法](#4%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95)
    * [4\.1 垃圾回收算法概述](#41-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0)
    * [4\.2 垃圾回收算法分类](#42-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB)
    * [4\.3 标记清除算法](#43-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95)
    * [4\.4 标记压缩算法](#44-%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95)
    * [4\.5 分代收集算法](#45-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95)
    * [4\.6 引用计数算法](#46-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95)
    * [4\.7 复制回收算法](#47-%E5%A4%8D%E5%88%B6%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95)
    * [4\.8 增量回收算法](#48-%E5%A2%9E%E9%87%8F%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95)
  * [5\.golang垃圾回收](#5golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)
    * [5\.1 golang垃圾回收算法](#51-golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95)
    * [5\.2 golang垃圾回收细节](#52-golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%BB%86%E8%8A%82)
    * [5\.3写屏障](#53%E5%86%99%E5%B1%8F%E9%9A%9C)
    * [5\.4辅助gc](#54%E8%BE%85%E5%8A%A9gc)
  * [6\.golang垃圾回收和java垃圾回收对比](#6golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8Cjava%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%AF%B9%E6%AF%94)
    * [6\.1 golang vs java](#61-golang-vs-java)
  * [7\.参考资料](#7%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)


## 1.垃圾回收是什么？

计算机世界和现实生活有很多相通的地方，生活中我们也存在垃圾箱，清洁工，垃圾回收站，垃圾分类回收等工作。在计算机中也是一样，下面将从“什么是垃圾”、“什么是垃圾回收”两个方面介绍这部分内容。

### 1.1 什么是垃圾？
在计算机中，通常将应用程序没有在使用的对象，定义为垃圾对象。广泛意义来理解，如果应用程序在工作开始时分配了一个对象或者内存空间，当使用完后，后续不再利用，此时这些已经没有再被利用的空间或对象都可以归为垃圾。一句话总结为：**已经被分配但不再被使用的对象、内存空间被称为垃圾，需要被回收，以便节约资源和开销**

### 1.2 什么是垃圾回收？

搞定了垃圾的定义之后，我们很容易就理解垃圾回收了，**垃圾回收(Garbage Collection缩写GC)就是将无用的但是仍然占据空间的对象从内存中释放，归还其占用的内存给系统，以供系统中其他应用程序循环利用，节约资源。**  
其实这个概念和现实生活很类似，回想下当我们把吃完的饭盒、零食袋以及其他不用的东西，我们理所当然会放入垃圾袋中，然后出门的时候放到垃圾箱，供清洁工回收。综上，有了生活的常识，不能理解计算机中的垃圾回收这个概念啦

## 2.为什么需要垃圾回收？

其实如果回答这个问题，我们乍一看不太好回答，但是换个问法，可能更容易想到答案。例如这个问题也可以改成“如果一直不回收垃圾会有什么问题？”，这样一换，存在的问题就显而易见了。
**下面对上述问题总结为三点：**

1. 如果不回收垃圾，无用的垃圾一直占用空间，近而**导致资源利用率降低**
2. 如果不回收垃圾，无用的垃圾会越来越多，近而**导致系统变的越来越慢**
3. 如果不回收垃圾，我们的系统总有一天会被垃圾吞噬掉，**极端情况下系统将变得不可用**


**综上，我们需要垃圾回收**，更进一步说，我们需要智能的回收垃圾（什么时候回收垃圾、多久回收一次垃圾等等），后面将一一进行阐述，计算机界的泰斗们是如何解决这类问题的。

## 3.什么时候触发垃圾回收？

我们知道，如果系统频繁的回收垃圾，会导致系统的服务受到影响，但是如果回收垃圾频率太慢，又会导致垃圾回收速率跟不上垃圾生产速率，近而垃圾越来越多，也不利于系统的稳定运行，因此必须设计在二者之间选择一个合适的策略，来进行回收垃圾，也就是下文将要介绍的，垃圾回收的触发条件。

### 3.1 垃圾回收触发条件
如果我们自己来设计一个垃圾回收的机制的话，最容易想到的一种策略是**按照一定的定时间隔来回收垃圾，例如每5min回收一次垃圾或者没2min回收一次垃圾**。这种策略虽然能直观的解决问题。但是也随之带来了新的问题。当我们的系统在某段时间高负载运行时，例如每天的流量高峰期（晚上八点到十点）。这时由于请求量比平常的大的多，因此垃圾的产生速率也大大增加了，因此定时清理垃圾的策略貌似不太友好。为了解决此类问题，我们又会想到另一种策略：**当系统中产生的垃圾到达一定的阈值时，主动回收垃圾**。至此，我们已经有了两种处理垃圾回收的条件，总结如下：

**1. 按照定时间隔回收垃圾**  
**2. 设置垃圾占用空间的阈值，到达阈值时，回收垃圾**  


**题外话：**
依稀记得之前做的一个项目，大概功能是统计线上一个物品的点击数和曝光数，然后存储到kv中，供线上其他模块使用。在该项目中，为了减少频繁读写kv的次数，是对每个物品维度做了计数累加缓存，缓存一段时间批量写一次kv。在该过程中，写kv的逻辑可以和上述垃圾回收想类比。幸运的是在项目中也是采用了两种策略来控制写kv的频率。


**搞清楚了上述两种策略后，很庆幸的告诉大家，计算机界泰斗级人物对垃圾回收的触发条件也是采用了这两种方式。目前主流的垃圾回收也是上述两种策略**


### 3.2 线上垃圾回收出现的问题

我们假设一个场景：假设回收100M空间的垃圾，在cpu正常满足垃圾回收100%时，需要耗时10us。如果再程序运行过程中，某次回收垃圾时，cpu只能有50%能用于垃圾回收时，此时在回收同样大小的垃圾空间时，耗时将会变成20us。依次类推。

在之前线上服务中，偶尔会发生这种gc1-10ms、gc10ms-50ms的数量会增加，平常这部分数量很少。最后排查完查到是因为正常情况下，能用于回收拉圾的cpu是充足的，因此耗时较短，当在高峰期时，能用于回收垃圾的cpu不充足时，会导致回收同样大小的垃圾耗时变长。



## 4.垃圾回收算法

在了解清楚了垃圾回收策略后，本部分主要对主流的一些垃圾回收算法的基本思想做一些介绍，不同语言支持的垃圾回收算法不尽相同。但其实现的原理是不变的，只有理清了算法本质，才能做到触类旁通，举一反三。


### 4.1 垃圾回收算法概述

**垃圾回收算法：**顾名思义，就是解决垃圾回收的一些成熟的方法，其用来解决的无非就是两个点：  
1. 怎么从大量的应用程序分配的对象和内存中，检测和识别出垃圾对象  
2. 识别出垃圾对象后，如何对其进行回收  

### 4.2 垃圾回收算法分类

主流的垃圾回收算法有如下几种：  
**1. 标记清除算法（mark-sweep）**  
**2. 标记压缩算法（mark-compact）**  
**3. 分代收集算法（）**  
**4. 引用计数算法（Reference Counting）**  
**5. 复制回收算法（Complication）**  
**6. 增量式回收算法** 

上述几种垃圾回收算法都存在各自的优缺点，下文将一一对其进行介绍。
 
### 4.3 标记清除算法

标记清除算法分为两个阶段：  
**1.标记阶段**  
标记阶段主要是用来标记被引用的对象，具体流程为：在语言jvm层面，后台会维护一个根节点集合，类似树的结构（父子节点表示引用关系）。在标记时，首先从根节点出发，然后依次遍历其子节点，当遍历完后，将遍历到的节点（也就是被引用的对象）进行打标记。
**2.清除阶段**  
通过第一阶段的标记，此时被引用的对象和未被引用的对象已经完成分离出来了。清除阶段将所有未被引用的对象连接到**空散列表链表上**，清理这对象，释放资源

 
**优点：** 该算法的优点是实现简单，容易和其他算法进行结合  
**缺点：**   

* 碎片化，导致无数小分块散落在各处  
* 分配速度较慢，每次分配对象时，需要扫描空闲链表，找到满足分配空间的内存块进行分配  
* 与写时复制技术不兼容，每次都会在引用对象上打标记
  
**存在问题：**  

1. 当标记过程中，会存在stop the world阶段


### 4.4 标记压缩算法

标记压缩算法和标记清除算法类似，不过该算法主要的目的在于优化**“标记清除算法中存在的碎片化内存”**的问题。具体为：在标记阶段将所有引用的对象做一个标记，标记完后，将所有标记对象紧密的排在堆的一侧（所谓的压缩）。**该算法主要是消除了内存碎片**

**特别注意：**该算法总共需要遍历至少3次堆空间。

1. **第一遍：**扫描堆空间，对引用对象做标记
2. **第二遍：**扫描堆空间，重新确定每个标记对象的新地址
3. **第三遍：**扫描堆空间，移动对象（做压缩）

**优点：**有效利用堆的空间，避免了内存碎片。

**缺点：**压缩过程需要额外的开销，需要多次遍历堆


### 4.5 分代收集算法

**分代收集算法基本思想：**大部分情况下，应用程序中的生成的对象其存活时间都不会很长，通常的场景是，创建完对象，使用对象，然后销毁对象。基于此类共识，产生了分代收集算法，它将堆空间做了一定的划分，主体分为：**新生代**、**老年代**。  

新生代(minor)：对象生成空间+2个幸存区（**复制算法**）  
老年代(major)：**标记清除算法**or**标记压缩算法** 

**gc的具体流程如下：**  
首先在对象生成空间创建新对象，当生成空间占满以后，进行minor GC，此过程中，将仍然存活的对象移动到一个幸存区中，并累加对象的年龄age,当这个幸存区满了以后，再次将该幸存区和生成空间中的对象移动到剩余一个幸存区中，同时也继续累加对象年龄age。当对象年龄达到一定阈值后，将其移动到老年代空间中。

当老年代的空间也满了以后，就用标记清除算法或者标记压缩算法对其进行major gc回收。

![http://ifeve.com/wp-content/uploads/2014/07/young_gc.png](http://ifeve.com/wp-content/uploads/2014/07/young_gc.png)


**优点：**

1. 该算法使得吞吐量大大提升
2. gc耗时减少，大约是gc复制算法的1/4

**缺点：**

1. 如果应用程序分配的对象时需要长期存活的，此时该算法效率会比较低，因为会频繁发生对象的复制和移动


### 4.6 引用计数算法

**引用计数算法：**顾名思义是对对象的引用次数进行统计，例如：当新建对象、赋值引用、删除引用时，同步更新对象的引用计数值。当计数值为0时，对该对象进行回收  

**优点：** 可以立即回收对象，最大暂时时间比较短  

**缺点：**   
1. 存在循环引用的问题，导致对象无法回收  
2. 引用计数统计工作比较繁重  
3. 实现繁琐复杂，每次每个对象的赋值操作都需要同步更新引用计数  

### 4.7 复制回收算法

**复制回收算法的思想是：**首先将堆分为两个部分，记做from和to，在初始时先使用from区的内存进行分配，使用一段时间后，当from区满了的时候，此时将from区的引用对象复制到to区中，然后交换两个空间，通过这种方式即可完成GC操作。

**优点：**

1. 该算法垃圾回收较为便捷，只需要交换两个空间即可
2. 该算法不会产生内存碎片
3. 因为分块是连续的，不需要使用空闲链表，因此可以实现快速分配内存
4. 优秀的吞吐量，只需要关心引用对象


**缺点：**

1. 堆空间利用率不高，通常只能使用一块分区的空间
2. 在函数递归调用时，复制子对象需要递归调用复制函数，比较消耗栈空间
3. 该算法和保守式GC算法不兼容

**保守式GC：**可以参考具体[这篇文章介绍](https://www.jianshu.com/p/a8a04fd00c3c)


### 4.8 增量回收算法

**总体上，gc是在后台执行的任务，但是如果gc执行任务繁重，则会长时间暂停应用程序的执行，增量式gc就是一种逐渐推进垃圾回收来控制mutator最大暂停时间的方法**


## 5.golang垃圾回收

前面介绍完垃圾回收的相关知识后，接下来具体看看go语言中的垃圾回收机制。有了前面的铺垫，我们在学习时，只需要掌握如下几个点：

**1. golang中的采用的垃圾回收算法是哪类？**  
**2. golang垃圾回收的过程？**  

下面将按照上述思路一一进行介绍。

### 5.1 golang垃圾回收算法

在go语言中，采用的垃圾回收算法是：**标记清除法(三色标记法)**。在原始标记清除算法的基础上，对其做了优化，改进后的算法为**三色标记法**  

**三色标记法：**三色标记法，顾名思义是将对象用白、灰、黑三种颜色来标记，三色标记算法分为两个阶段：  
**1. 标记阶段：**
初始时所有对象均为白色，放置在白色队列中，接着将root根节点（root区域主要是程序运行到当前时刻的栈和全局数据区域）标记为灰色，放入灰色队列，并从root根节点开始依次遍历，如果该节点有引用的对象，则将其引用的对象也加入到灰色队列中，并将该节点移动到标记为黑色，并移动到黑色队列中。依次反复遍历灰色队列中的对象，直到灰色队列为空。  最终对象只会出现白色和黑色两种颜色。黑色对象为引用的对象，白色对象为可以被回收掉的对象。至此标记阶段就已完成。  
**2. 清除阶段：** 将第一阶段中的白色对象进行清理。

**具体过程参考如下动画演示**

![搞懂 Go 垃圾回收](https://static.gocn.vip/photo/2020/cff2edea-9804-411e-acd7-a94c4397b4d8.gif?x-oss-process=image/resize,w_1920)

> 图片引自https://gocn.vip/topics/9986

### 5.2 golang垃圾回收细节

golang 执行GC是和用户代码执行时并行的，GC期间用户可能会改变某些对象的状态。下面详细进行介绍回收细节

1. 标记阶段：包含两部分
	1.  标记准备阶段:初始化GC任务，开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等，这个过程需要STW(stop the world)
	2.  标记阶段:扫描所有的root对象，包括全局指针和goroutine（G）上的指针（扫描对应的G时停止该G），然后按照标记的流程进行标记

2. 标记完成： 完成标记工作后，重新扫描全局指针和栈，因为标记阶段是和用户程序并行的，所以在标记阶段可能会有新的对象被引用和赋值，这时候需要通过借助写屏障来记录对象的状态，重新扫描再检查一下，这个过程也会STW
3. 清除阶段：清除所有白色对象，该过程后台执行
4. 清除完成：对未清扫的span进行清扫，只有上一轮的GC的清扫工作完成后才会开始新一轮的GC

### 5.3写屏障

写屏障的基本含义是：该屏障之前的写操作和之后的写操作相比，会先被系统其他组件感知到

> 结合上面 GC 工作的完整流程就好理解了，就是在每一轮 GC 开始时会初始化一个叫做 “屏障” 的东西，然后由它记录第一次 scan 时各个对象的状态，以便和第二次 re-scan 进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。


### 5.4辅助gc

> 从上面的 GC 工作的完整流程可以看出 Golang GC 实际上把单次暂停时间分散掉了，本来程序执⾏可能是 “⽤户代码-->⼤段 GC-->⽤户代码”，那么分散以后实际上变成了 “⽤户代码-->⼩段 GC-->⽤户代码-->⼩段 GC-->⽤户代码” 这样。如果 GC 回收的速度跟不上用户代码分配对象的速度呢？ Go 语⾔如果发现扫描后回收的速度跟不上分配的速度它依然会把⽤户逻辑暂停，⽤户逻辑暂停了以后也就意味着不会有新的对象出现，同时会把⽤户线程抢过来加⼊到垃圾回收⾥⾯加快垃圾回收的速度。这样⼀来原来的并发还是变成了 STW，还是得把⽤户线程暂停掉，要不然扫描和回收没完没了了停不下来，因为新分配对象⽐回收快，所以这种东⻄叫做辅助回收

## 6.golang垃圾回收和java垃圾回收对比


### 6.1 golang vs java


## 7.参考资料 

1. [几种垃圾回收算法](https://www.jianshu.com/p/a8a04fd00c3c)
2. [聊聊JVM的年轻代](http://ifeve.com/jvm-yong-generation/)
3. [搞懂 Go 垃圾回收](https://gocn.vip/topics/9986)
4. [Golang GC 核心要点和度量方法](https://gocn.vip/topics/9822)