# redis sentinel原理


## 1. 为什么需要redis sentinel

首先redis主从复制的架构，虽然实现了系统的可用，但是未达到高可用的效果。故障发生时，只能通过告警运维人员，然后通过手动转移故障的操作来解决故障

其次在业务中，通过不同业务采用不同的redis集群来存储数据，对于多套redis主从架构来说，每一套都需要运维人员来处理，工作量繁杂，运维成本高



## 2. redis sentinel是什么

上文提到，在redis 主从复制的架构中，当master节点发生故障时，无法做到故障监控、自动转移。为了解决这个问题。redis官方退出了redis sentinel集群模式，该模式是对redis主从复制的一种改进。

**redis-sentinel本质：** redis sentinel其实是在redis的主从复制的基础上，增加了一套监控redis节点的独立集群，该集群主要功能如下 
 
1. **监控redis节点**   
2. **当故障发生时实现自动转移**  
3. **redis sentinel可以实现多套redis集群的监控，通过多套redis集群通过cluster name区分**



## 3. redis sentinel的使用

下文将搭建一个1主2存的redis server。并同时再此基础上增加3个redis sentinel节点来对其多监控和故障转移


**redis server：**6379（master）、6380（slave）、6381（slave）  
**redis sentinel：**26379、26380、26381  
### 3.1 redis server 配置文件

#### 3.1.1 操作步骤

``` shell

 cat redis.conf|grep -v "^$"|grep  -v "#"
 cat redis.conf|grep -v "^$"|grep  -v "#"  > redis-6379.conf
 
 vim redis-6379.conf
 sed 's/6379/6380/g' redis-6379.conf
 sed 's/6379/6380/g' redis-6379.conf >redis-6380.conf
 sed 's/6379/6381/g' redis-6379.conf >redis-6381.conf

```

#### 3.1.2 redis server 重要配置

**以6379的server为例**

```shell
bind 127.0.0.1
protected-mode yes
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300
daemonize yes
supervised no
pidfile ../data/6379.pid
loglevel notice
logfile "../data/6379.log"
databases 16
always-show-logo yes
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump-6379.rdb



slaveof 127.0.0.1 port :设置主从关系
```


### 3.2 启动redis server

**1. 启动redis server**

```shell
	
 ./redis-server ../config/redis-6379.conf
 ./redis-server ../config/redis-6380.conf
 ./redis-server ../config/redis-6381.conf
 
 ps -ef |grep redis
```

**2. 查看redis的主从关系**

**2.1 6379:master**

```shell
➜  ~/learn-redis/bin ./redis-cli
127.0.0.1:6379> role
1) "master"
2) (integer) 238
3) 1) 1) "127.0.0.1"
      2) "6380"
      3) "238"
   2) 1) "127.0.0.1"
      2) "6381"
      3) "238"
127.0.0.1:6379> exit
```

**2.2 6380/6381:slave**

```shell
➜  ~/learn-redis/bin ./redis-cli -p 6380
127.0.0.1:6380> role
1) "slave"
2) "127.0.0.1"
3) (integer) 6379
4) "connected"
5) (integer) 322
127.0.0.1:6380> exit
➜  ~/learn-redis/bin ./redis-cli -p 6381
127.0.0.1:6381> role
1) "slave"
2) "127.0.0.1"
3) (integer) 6379
4) "connected"
5) (integer) 336
127.0.0.1:6381>
```


### 3.3 redis sentinel 配置文件

**以redis sentinel 26379配置文件为例**

```shell
port 26379
daemonize yes
pidfile ../data/redis-sentinel-26379.pid
logfile "../data/26379.log"
dir ../data/

# 如果监控多套集群通过名字mymaster区分
# sentinel monitor name ip port quorm  quorm：指对redis server主观下线的sentinel达到几个就可以对该redis server进行客观下线
sentinel monitor mymaster 127.0.0.1 6379 2

# 主观下线的毫秒时间，达到多长时间没响应就认为是主管下线
sentinel down-after-milliseconds mymaster 30000
# 故障转移后，新的master将数据同步给slave时，并行同步的slave个数
sentinel parallel-syncs mymaster 1
# sentinel故障转移的超时时间，默认是180s
sentinel failover-timeout mymaster 180000
# 拒绝脚本重配置
sentinel deny-scripts-reconfig yes

```

**配置sentinel的三个配置文件**


```shell
 cat sentinel.conf|grep -v "#" |grep -v "^$"   > sentinel-26379.conf
 wc -l sentinel-26379.conf
 vim sentinel-26379.conf
 cat sentinel-26379.conf
 sed 's/26379/26380/g' sentinel-26379.conf > sentinel-26380.conf
 sed 's/26379/26381/g' sentinel-26379.conf > sentinel-26381.conf
 cat sentinel-26381.conf

```

### 3.4 启动redis sentinel集群


**3.4.1 启动sentinel集群**

```shell
 ./redis-sentinel ../config/sentinel-26379.conf
 ./redis-sentinel ../config/sentinel-26380.conf
 ./redis-sentinel ../config/sentinel-26381.conf
 ps -ef |grep sentinel
 ps -ef |grep sentinel|grep -v grep
```

**3.4.2 查看sentinel角色**

```shell
➜  ~/learn-redis/bin ./redis-cli
127.0.0.1:6379>
➜  ~/learn-redis/bin ./redis-cli  -p 26379
127.0.0.1:26379> role
1) "sentinel"
2) 1) "mymaster"
127.0.0.1:26379> exit
➜  ~/learn-redis/bin ./redis-cli  -p 26380
127.0.0.1:26380> role
1) "sentinel"
2) 1) "mymaster"
127.0.0.1:26380> exit
➜  ~/learn-redis/bin ./redis-cli  -p 26381
127.0.0.1:26381> role
1) "sentinel"
2) 1) "mymaster"
127.0.0.1:26381> exit
➜  ~/learn-redis/bin

```

### 3.5 查看sentinel启动后的配置文件

```shell
➜  ~/learn-redis/bin cat ../config/sentinel-26379.conf
port 26379
daemonize yes
pidfile "../data/redis-sentinel-26379.pid"
logfile "../data/26379.log"
dir "/Users/wenxiaofei/learn-redis/data"
sentinel myid b1e0bc3a1993b20b951d70c3bdcf9a269e782b52
sentinel deny-scripts-reconfig yes
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
# Generated by CONFIG REWRITE
# sentinel重写的配置
protected-mode no
user default on nopass ~* +@all
sentinel known-replica mymaster 127.0.0.1 6381
sentinel known-replica mymaster 127.0.0.1 6380
sentinel known-sentinel mymaster 127.0.0.1 26380 9a8471e8595fef8796cf2d20c8bfb55ab8c4291c
sentinel known-sentinel mymaster 127.0.0.1 26381 9f4afb4be7b3e0b35ed2e6da85b53330b3add031
sentinel current-epoch 0
```


## 4. redis sentinel的原理

### 4.1 master发生故障时，自动转移故障步骤

1. **master主观下线**  
	2. 当sentinel超过指定的down-after-milliseconds后，则判定为该master主管下线  
	3. 然后开始发送sentinel is-master-down-by-addr 命令询问其他的sentinel节点，是否master已经下线  
2. **master客观下线**    
	3. 当sentinel收到其他sentinel节点的is-master-down-by-addr的回复后，进行统计，如果有超过quorm个sentinel任务master下线，则此时会判定该master客观下线   	
3. **选举sentinel领导者**  
	4.  当master客观下线后，需要从sentinel集群中选择一个sentinel领导者节点，用来完成后面的故障转移操作。选举操作如下   
		5. 发送sentinel is-master-down-by-addr 命令开始发起投票，希望其他sentinel选举自己为领导者  
		6. 收到命令的sentinel如果没有同意其他的sentinel为领导者，那么将同意该请求  
		7. 如果当前的sentinel发现自己的票数已经达到了sentinel集群的半数以上，则它将成为领导者  
		8. 如果此过程有多个sentinel都成为领导者，则等待一段时间后将继续选举  
4. **选举新的master节点**    
	5. sentinel领导者将从多个slave中选择一个节点为新的master节点，选举逻辑如下
		6.  首先根据配置文件中配置的slave-priority属性优先级来选择，如果存在优先级最高的返回，否则继续选择  
		7.  选择复制的偏移量最大的slave节点(复制最完整)，如果存在则返回，否则继续  
		8.  前两步都没有选出来新的master的话，则选择runId最小的节点(启动最早的节点)作为master节点  
5. **故障转移**    
	6. 故障转移的步骤  
		7.  首选将新选择的master节点执行slaveof no one，让其恢复为master节点  
		8.  对其他的slave节	点执行slaveof newMasterIp newMasterPort，让其成为新的master节点的slave节点  
		9. 更新原来的master节点为slave，并保持着对其关注，当其恢复后命令它去复制新的master节点。    


## 5. 三个定时任务

### 5.1 每10s一次
在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO [section] 命令。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO [section] 命令的频率会从 10 秒一次改为每秒一次。

1. 发现slave节点
2. 发现主从关系

### 5.2 每2s一次

每个 Sentinel 会以每两秒一次的频率， 通过发布与订阅功能， 向被它监视的所有主服务器和从服务器的 \_\_sentinel__:hello 频道发送一条信息， 信息中包含了 Sentinel 的 IP 地址、端口号和运行 ID （runid）。

每个 Sentinel 都订阅了被它监视的所有主服务器和从服务器的 __sentinel__:hello 频道， 查找之前未出现过的 sentinel （looking for unknown sentinels）。 当一个 Sentinel 发现一个新的 Sentinel 时， 它会将新的 Sentinel 添加到一个列表中， 这个列表保存了 Sentinel 已知的， 监视同一个主服务器的所有其他 Sentinel 。

Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。

在将一个新 Sentinel 添加到监视master的列表上面之前， Sentinel 会先检查列表中是否已经包含了和要添加的 Sentinel 拥有相同运行 ID 或者相同地址（包括 IP 地址和端口号）的 Sentinel ， 如果是的话， Sentinel 会先移除列表中已有的那些拥有相同运行 ID 或者相同地址的 Sentinel ， 然后再添加新 Sentinel

### 5.3 每1s一次

每个 Sentinel 以每秒钟一次的频率向它所知master、slave以及其他 Sentinel 实例发送一个 PING 命令。

如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 一个有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。

## 6. 参考资料

1. [redis Sentinel document](http://redisdoc.com/topic/sentinel.html)
2. [Redis Sentinel Documentation](https://redis.io/topics/sentinel)